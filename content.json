{"meta":{"title":"Su's Blog","subtitle":"Day Day Up","description":null,"author":"SuQ","url":"http://yoursite.com"},"pages":[{"title":"Nginx + uWSGI 部署Django项目","date":"2018-01-17T12:34:06.000Z","updated":"2018-02-25T08:27:57.966Z","comments":true,"path":"Nginx-uWSGI-部署Django项目backup.html","permalink":"http://yoursite.com/Nginx-uWSGI-部署Django项目backup.html","excerpt":"","text":"Linux下python环境搭建。 查看系统所有版本信息： 查看python版本。一般系统自带python2。我用的是python3所以需要自己安装。2.0 安装可能需要的依赖包yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel2.1 下载 wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0a1.tar.xz 2.2 解压 tar xvf Python-3.6.0a1.tar.xz 2.3 编译安装: ​ 2.3.1 进入目录./configure 配置。Configure是一个可执行脚本，它有很多选项，使用命令./configure –help输出详细的选项列表。常用的是 –prefix。比如打算把它安装到目录/usr/local/python3,于是在python3目录执行带选项的脚本./configure –prefix=/usr/local/python3执行成功后再编译、安装（make，make install）；安装完成将自动生成目录python6而且该软件所有的文件都被复制到这个目录。指定这个选项是为了以后的维护方便，如果没有用这个选项，安装过程结束后，该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文件、都复制到哪里去了—基本上是一塌糊涂。当需要卸载软件或移植软件，只要删除这个目录就行 ​ 2.3.2 make &amp;&amp; make install 编译（make）并安装（make install） ​ 如果编译遇到问题： 根据需要安装对应的模块 2.4 查看是否安装成功：python3 如果还是提示python3命令不存在，创建软链 ln -s /usr/local/python3.6/bin/python3 /usr/bin/python3 pip3 。一般python3源码会自带pip3，所以不需要另行安装。查看pip3的版本：python3 -m pip -V。之前不清楚python3自带pip3.所以自己安装了， pip下载：wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9 安装pip： tar -xzvf pip-1.5.4.tar.gz cd pip-1.5.4 python setup.py install 用pip -V查看版本看到的是python2上的pip。我不确定以上命令是否能正确将pip装到python3上，或者可以尝试用python3 setup.py install 升级pip:python3 -m pip install –upgrade pip 安装Django。系统如果同时有python2和python3.安装第三方包一般会默认用python2装，如果想用python3安装第三方包，使用python3 -m pip install packagename。可以参考官方文档：https://docs.python.org/3/installing/ python3 -m pip install Django 如果不在pip install 前加python3 -m会报错：AttributeError: module ‘importlib._bootstrap’ has no attribute ‘SourceFileLoader’ 或者是pip: command not found 安装虚拟环境。python3 -m pip install virtualenv 。 5.1 查看路径，which virtualenv找到路径后创建虚拟环境：/usr/local/bin/virtualenv my_work (my_work是我的虚拟环境名称) ​ 5.2 进入虚拟环境目录/usr/local/bin/my_work，然后激活 source bin/activate 5.3 进入my_work的bin目录，安装依赖包pip3 install -r requirements.txt(这个要写是django项目的requirements.txt的绝对路径)。 安装成功后，如下所示： 如果没有安装项目对应的扩展包，在运行项目的时候则会出现一下问题。 如果使用完毕需要退出虚拟环境：deactivates 运行开发服务器测试，进入项目目录（/root/qunsu/proj/qa_cg），修改子目录qa_cg/settings.py文件中的ALLOWED_HOSTS = [],添加上部署的机器的ip。在虚拟环境下运行 python3 /home/tester/qunsu/qa_cg/manage.py runserver 0.0.0.0:8000。确保能正常打开网站。 在运行的时候如果报错： 找到报错的代码（base.py）。然后将if version &lt; (1, 3, 3): raise ImproperlyConfigured(“mysqlclient 1.3.3 or newer is required; you have %s” % Database.version)注释掉。 安装nginx等软件，使用的机器的系统是centos。 yum install epel-release yum install python-devel nginx 没有安装supervisor。python3安装一直报错，貌似supervisor支持python2 关闭防火墙，不确定不关闭有什么影响 service iptables stop 安装uwsgi python3 -m pip install uwsgi —upgrade 使用uwsgi运行项目，两种方法： 第一种：执行使用命令 uwsgi --http :8002 --chdir ``/path/to/project --home=``/path/to/env --module project.wsgi 如果端口已被占用，则lsof -i :8002找到对应的进程，kill掉。或者修改uwsgi的端口。 第二种：创建配置文件在项目下创建配置文件/root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini。 文件内容： qa_cg_uwsgi.ini file [uwsgi] Django-related settings socket = :8002 the base directory (full path) chdir = /root/qunsu/proj/qa_cg Django s wsgi file module = qa_cg.wsgi process-related settings master master = true maximum number of worker processes processes = 4 ... with appropriate permissions - may be needed chmod-socket = 664 clear environment on exit vacuum = true 运行uwsgi:uwsgi /-/-ini /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini 以ini为配置文件启动uwsgi: uwsgi -x /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini 后台运行uwsgi并把日志写到/root/qunsu/logs/uwsgi.log里面: uwsgi -d /root/qunsu/logs/uwsgi.log 我用的命令：uwsgi /-/-ini /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini -d /root/qunsu/log.log关闭uwsgi服务killall -9 uwsgi ​ 关联nginx在nginx.conf配置 location ~ ^/ { include uwsgi_params; uwsgi_pass 192.168.233.108:8002; uwsgi_read_timeout 2; } 静态资源配置： location ^~ /static { alias /root/qunsu/proj/qa_cg/static/; } 运行nginx。进入nginx的sbin目录。./nginx -t 检查配置文件语法错误。./nginx -s reload 重新加载配置文件"},{"title":"","date":"2017-07-28T07:42:04.000Z","updated":"2017-07-28T07:42:04.000Z","comments":true,"path":"readme.html","permalink":"http://yoursite.com/readme.html","excerpt":"","text":"部署三部曲： hexo clean hexo generate #生成静态页面到public目录 hexo deploy #部署.deploy项目到github 常用命令： hexo new “postName” #新建文章 hexo new page “pagename” #新建页面"},{"title":"about","date":"2017-07-29T08:17:54.000Z","updated":"2017-07-29T08:17:54.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-07-29T08:13:55.000Z","updated":"2017-07-29T08:14:41.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-29T08:18:21.000Z","updated":"2017-07-29T08:19:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"shell脚本","slug":"shell脚本","date":"2018-02-05T05:28:18.000Z","updated":"2018-02-05T05:30:22.144Z","comments":true,"path":"2018/02/05/shell脚本/","link":"","permalink":"http://yoursite.com/2018/02/05/shell脚本/","excerpt":"","text":"遇到的坑： if 条件判断：判断上条命令是否执行成功。报错 [0: command not found是因为if语句的格式问题：if空格[空格$? -eq 0空格]; if后面加空格，条件两边也得加空格if [ $? -eq 0 ]; then echo &#39;find success&#39; echo $deps else echo &#39;find failed&#39; fi","categories":[],"tags":[]},{"title":"Nginx + uWSGI 部署Django项目","slug":"Nginx-uWSGI-部署Django项目","date":"2018-01-17T12:34:06.000Z","updated":"2018-02-25T08:35:08.317Z","comments":true,"path":"2018/01/17/Nginx-uWSGI-部署Django项目/","link":"","permalink":"http://yoursite.com/2018/01/17/Nginx-uWSGI-部署Django项目/","excerpt":"","text":"Linux下python环境搭建。 查看系统所有版本信息： 查看python版本。一般系统自带python2。我用的是python3所以需要自己安装。2.0 安装可能需要的依赖包yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel2.1 下载 wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0a1.tar.xz 2.2 解压 tar xvf Python-3.6.0a1.tar.xz 2.3 编译安装: ​ 2.3.1 进入目录./configure 配置。Configure是一个可执行脚本，它有很多选项，使用命令./configure –help输出详细的选项列表。常用的是 –prefix。比如打算把它安装到目录/usr/local/python3,于是在python3目录执行带选项的脚本./configure –prefix=/usr/local/python3执行成功后再编译、安装（make，make install）；安装完成将自动生成目录python6而且该软件所有的文件都被复制到这个目录。指定这个选项是为了以后的维护方便，如果没有用这个选项，安装过程结束后，该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文件、都复制到哪里去了—基本上是一塌糊涂。当需要卸载软件或移植软件，只要删除这个目录就行 ​ 2.3.2 make &amp;&amp; make install 编译（make）并安装（make install） ​ 如果编译遇到问题： ​ 根据需要安装对应的模块 ​ 2.4 查看是否安装成功：python3 ​ 如果还是提示python3命令不存在，创建软链 ln -s /usr/local/python3.6/bin/python3 /usr/bin/python3 pip3 。一般python3源码会自带pip3，所以不需要另行安装。查看pip3的版本：python3 -m pip -V。之前不清楚python3自带pip3.所以自己安装了， pip下载：wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9 安装pip： tar -xzvf pip-1.5.4.tar.gz cd pip-1.5.4 python setup.py install 用pip -V查看版本看到的是python2上的pip。我不确定以上命令是否能正确将pip装到python3上，或者可以尝试用python3 setup.py install 升级pip:python3 -m pip install –upgrade pip 安装Django。系统如果同时有python2和python3.安装第三方包一般会默认用python2装，如果想用python3安装第三方包，使用python3 -m pip install packagename。可以参考官方文档：https://docs.python.org/3/installing/ python3 -m pip install Django 如果不在pip install 前加python3 -m会报错：AttributeError: module ‘importlib._bootstrap’ has no attribute ‘SourceFileLoader’ 或者是pip: command not found 安装虚拟环境。python3 -m pip install virtualenv 。 5.1 查看路径，which virtualenv找到路径后创建虚拟环境：/usr/local/bin/virtualenv my_work (my_work是我的虚拟环境名称) 5.2 进入虚拟环境目录/usr/local/bin/my_work，然后激活 source bin/activate 5.3 进入my_work的bin目录，安装依赖包pip3 install -r requirements.txt(这个要写是django项目的requirements.txt的绝对路径)。 安装成功后，如下所示： 如果没有安装项目对应的扩展包，在运行项目的时候则会出现一下问题。 如果使用完毕需要退出虚拟环境：deactivates 运行开发服务器测试，进入项目目录（/root/qunsu/proj/qa_cg），修改子目录qa_cg/settings.py文件中的ALLOWED_HOSTS = [],添加上部署的机器的ip。在虚拟环境下运行 python3 /home/tester/qunsu/qa_cg/manage.py runserver 0.0.0.0:8000。确保能正常打开网站。 在运行的时候如果报错： 找到报错的代码（base.py）。然后将if version &lt; (1, 3, 3): raise ImproperlyConfigured(“mysqlclient 1.3.3 or newer is required; you have %s” % Database.version)注释掉。 安装nginx等软件，使用的机器的系统是centos。 yum install epel-release yum install python-devel nginx 没有安装supervisor。python3安装一直报错，貌似supervisor支持python2 关闭防火墙，不确定不关闭有什么影响 service iptables stop 安装uwsgi python3 -m pip install uwsgi —upgrade 使用uwsgi运行项目，两种方法： 第一种：执行使用命令 uwsgi --http :8002 --chdir ``/path/to/project --home=``/path/to/env --module project.wsgi 如果端口已被占用，则lsof -i :8002找到对应的进程，kill掉。或者修改uwsgi的端口。 第二种：创建配置文件在项目下创建配置文件/root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini。 文件内容： qa_cg_uwsgi.ini file [uwsgi] Django-related settings socket = :8002 the base directory (full path) chdir = /root/qunsu/proj/qa_cg Django s wsgi file module = qa_cg.wsgi process-related settings master master = true maximum number of worker processes processes = 4 ... with appropriate permissions - may be needed chmod-socket = 664 clear environment on exit vacuum = true 运行uwsgi:uwsgi /-/-ini /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini 以ini为配置文件启动uwsgi: uwsgi -x /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini 后台运行uwsgi并把日志写到/root/qunsu/logs/uwsgi.log里面: uwsgi -d /root/qunsu/logs/uwsgi.log 我用的命令：uwsgi /-/-ini /root/qunsu/proj/qa_cg/qa_cg_uwsgi.ini -d /root/qunsu/log.log关闭uwsgi服务killall -9 uwsgi ​ 关联nginx在nginx.conf配置 location ~ ^/ { include uwsgi_params; uwsgi_pass 192.168.233.108:8002; uwsgi_read_timeout 2; } 静态资源配置： location ^~ /static { alias /root/qunsu/proj/qa_cg/static/; } 运行nginx。进入nginx的sbin目录。./nginx -t 检查配置文件语法错误。./nginx -s reload 重新加载配置文件","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"","slug":"mac下同时装python2 和python3","date":"2017-12-08T11:28:38.598Z","updated":"2017-12-08T11:47:02.257Z","comments":true,"path":"2017/12/08/mac下同时装python2 和python3/","link":"","permalink":"http://yoursite.com/2017/12/08/mac下同时装python2 和python3/","excerpt":"","text":"mac下同时装python2 和python3 安装xcode。（貌似可以不装） 遇到的问题：mac os的版本太低。在应用商店安装是提示：不能将软件安装在Macintosh hd上,因为需要mac更高版本 解决方案：升级mac os 安装套件管理工具homebrew a. 在终端输入：ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” b. 安装后输入brew doctor ，如果是出现Your system is ready to brew 安装python ​ a. 先看本机的python版本 python —version ​ b. 用homebrew搜索python： brew search python ​ brew search python​ python ✔ boost-python ipython python-markdown​ python3 ✔ boost-python@1.59 ipython@5 wxpython​ app-engine-python gst-python micropython zpython ​ c. 安装python ​ brew install python ​ brew install python3 ​ 遇到的问题：安装时提示安装成功但link python失败。重新用brew link python提示一样的失败原因 Linking /usr/local/Cellar/python/2.7.14… Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks 然后切换成管理员，如下所示 ➜ ~ sudo -iEBJ1165:~ root# brew link pythonError: Running Homebrew as root is extremely dangerous and no longer supported.As Homebrew does not drop privileges on installation you would be giving allbuild scripts full access to your system. 解决办法：原因是没有frameworks这个文件，只要新建这个文件sudo mkdir /usr/local/Frameworks，然后更改文件权限sudo chown $(whoami):admin /usr/local/Frameworks。或者在当前用户直接新建该文件。 查看结果，通过看python的安装路径来判断是否是系统的python which python which python3 参考https://stringpiggy.hpd.io/mac-osx-python3-dual-install/#step2","categories":[],"tags":[]},{"title":"photoshop mac 破解","slug":"photoshop-mac-破解","date":"2017-09-28T02:44:05.000Z","updated":"2017-09-28T02:46:36.000Z","comments":true,"path":"2017/09/28/photoshop-mac-破解/","link":"","permalink":"http://yoursite.com/2017/09/28/photoshop-mac-破解/","excerpt":"","text":"1、首先下载photoshop cc 2017 ,官网地址：http://www.adobe.com/cn/products/photoshop.html，右上角选择“免费试用”，进行下载photoshop cc 2017即可； 安装成功之后，如果安装成功之后自动打开，会弹出使用天数7天；这个时候，不要点击使用，应直接将软件关闭；进行破解； 2、下载补丁，下载地址：链接: https://pan.baidu.com/s/1eRK0IoM 密码: cw2b,解压，得到amtlib.framework文件，将文件拷贝.找到应用程序的photoshop，右键，显示包内容。打开之后，有一个Contents文件，然后点进去，会有一个Frameworks文件，将刚才解压到文件amtlib.framework拷贝进去，点击替换；（建议先备份一下要替换的文件）此时可以打开photoshop程序，如果程序无法启动，有闪退现象，则需要看第三步；如果正常，以下第三步可以 省略不看； 3、解决程序闪退的问题，下载补丁地址：链接: https://pan.baidu.com/s/1dFtEB2h 密码: h3y3 解压后，会有一个应用图标，点击即可；如果无法执行，请为其添加权限； 点击之后，再次打开photoshop程序，程序可以正常打开，并且不再提示使用7天的提示； 来自：http://www.bigzhong.com/wenzhang/20161121/14.html","categories":[],"tags":[]},{"title":"python2.x和python3.x","slug":"python2-x和python3-x","date":"2017-09-20T09:06:27.000Z","updated":"2017-09-20T09:35:10.000Z","comments":true,"path":"2017/09/20/python2-x和python3-x/","link":"","permalink":"http://yoursite.com/2017/09/20/python2-x和python3-x/","excerpt":"","text":"python 2.x MySQLdb在python3.x中用PyMySQL代替 python 解决NAMEError：name ‘reload’ is not defined的问题 对于python 2.x: 123import sysreload(sys)sys.setdefaultencoding(\"utf-8\") 对于python&lt;=3.3: 12345import impimp.reload(sys)'''python3与python 2有很大的区别，python3系统默认使用的是UTF-8编码，所以，对于使用的是python3的情况不需要使用sys.setdefaultencoding('utf-8')这段代码，并且python3中已经没有setdefaultencoding这个函数了 ''' 对于python&gt;=3.4: 12import importlibimportlib.reload(sys) 在python3中已经没有StringIO模块，修改为io模块%","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"梦幻花--东野圭吾","slug":"梦幻花-东野圭吾","date":"2017-09-20T08:43:35.000Z","updated":"2017-09-20T08:53:09.000Z","comments":true,"path":"2017/09/20/梦幻花-东野圭吾/","link":"","permalink":"http://yoursite.com/2017/09/20/梦幻花-东野圭吾/","excerpt":"","text":"上周末（9月17日）头昏脑涨，又无事可做，便用kindle看起书来。说实话，kindle买来那么久并没有用过几次，终于理解为什么那么多人买了之后没过多久又转手了。 理论的书看起来更增添反感，故而选了东野圭吾的书，推理小说总是能勾起人的兴趣来的。他的书看过几本，但大体都忘记名字，剧情也是只有一点记忆，都是看书过于浮躁的缘故，走马观花不经大脑。。。所以此次便想记它一记，增加印象。","categories":[{"name":"课外读物","slug":"课外读物","permalink":"http://yoursite.com/categories/课外读物/"}],"tags":[{"name":"小说, 推理","slug":"小说-推理","permalink":"http://yoursite.com/tags/小说-推理/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2017-09-04T09:45:41.000Z","updated":"2017-09-07T08:28:41.000Z","comments":true,"path":"2017/09/04/正则表达式/","link":"","permalink":"http://yoursite.com/2017/09/04/正则表达式/","excerpt":"（整理自http://cuiqingcai.com/977.html ） 正则表达式相关注解(1)数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 注：我们一般使用非贪婪模式来提取。","text":"（整理自http://cuiqingcai.com/977.html ） 正则表达式相关注解(1)数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 注：我们一般使用非贪婪模式来提取。 (2)反斜杠问题与大多数编程语言相同，正则表达式里使用”\\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。 Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\”表示。同样，匹配一个数字的”\\d”可以写成r”\\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观勒。 正则表达式的语法规则 python Re模块12345678910# 返回pattern对象re.compile(string[, flag])# 以下为匹配所用函数re.match(pattern, string[, flags])re.search(pattern, string[, flags])re.split(pattern, string[, maxsplit])re.findall(pattern, string[, flags])re.finditer(pattern, string[, flags])re.sub(pattern, repl, string[, count])re.subn(pattern, repl, string[, count]) 另一个参数flags，是匹配模式，取值可以使用按位或运算符’|’表示同时生效，例如re.I | re.M 可选的值有： 123456# re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）# re.M(全拼：MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图）# re.S(全拼：DOTALL): 点任意匹配模式，改变'.'的行为# re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定# re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于 unicode定义的字符属性# re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 1. re.match(pattern, string[,flags])这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配 Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859'''属性：1.string: 匹配时使用的文本。2.re: 匹配时使用的Pattern对象。3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。方法：1.group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。2.groups([default]):以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。3.groupdict([default]):返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。4.start([group]):返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。5.end([group]):返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。6.span([group]):返回(start(group), end(group))。7.expand(template):将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。'''#一个简单的match实例 import re# 匹配如下内容：单词+空格+单词+任意字符m = re.match(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', 'hello world!') print \"m.string:\", m.stringprint \"m.re:\", m.reprint \"m.pos:\", m.posprint \"m.endpos:\", m.endposprint \"m.lastindex:\", m.lastindexprint \"m.lastgroup:\", m.lastgroupprint \"m.group():\", m.group()print \"m.group(1,2):\", m.group(1, 2)print \"m.groups():\", m.groups()print \"m.groupdict():\", m.groupdict()print \"m.start(2):\", m.start(2)print \"m.end(2):\", m.end(2)print \"m.span(2):\", m.span(2)print r\"m.expand(r'\\g \\g\\g'):\", m.expand(r'\\2 \\1\\3') ### output #### m.string: hello world!# m.re: # m.pos: 0# m.endpos: 12# m.lastindex: 3# m.lastgroup: sign# m.group(1,2): ('hello', 'world')# m.groups(): ('hello', 'world', '!')# m.groupdict(): &#123;'sign': '!'&#125;# m.start(2): 6# m.end(2): 11# m.span(2): (6, 11)# m.expand(r'\\2 \\1\\3'): world hello! 2. re.search(pattern, string[, flags])search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。 1234567891011121314# 导入re模块import re# 将正则表达式编译成Pattern对象pattern = re.compile(r'world')# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = re.search(pattern, 'hello world!')if match: # 使用Match获得分组信息 print match.group() ### 输出 ### # world 3. re.split(pattern, string[, maxsplit])按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 12345pattern = re.compile(r'\\d+')print re.split(pattern, 'one1two2three3four4')### 输出 #### ['one', 'two', 'three', 'four', ''] 4. re.findall(pattern, string[, flags])搜索string，以列表形式返回全部能匹配的子串。 12345678import repattern = re.compile(r'\\d+')printre.findall(pattern, 'one1two2three3four4')### 输出 #### ['1', '2', '3', '4'] 5. re.finditer(pattern, string[, flags])搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 12345678import repattern = re.compile(r'\\d+')for m in re.finditer(pattern, 'one1two2three3four4'): print m.group()### 输出 #### 1 2 3 4 6. re.sub(pattern, repl, string[, count])使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 123456789101112pattern = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!'printre.sub(pattern, r'\\2 \\1', s)def func(m): return m.group(1).title() + ' ' + m.group(2).title()print re.sub(pattern, func, s)### output #### say i, world hello!# I Say, Hello World! 7. re.subn(pattern, repl, string[, count])返回 (sub(repl, string[, count]), 替换次数)。 1234567891011pattern = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!'printre.subn(pattern, r'\\2 \\1', s)def func(m): return m.group(1).title() + ' ' + m.group(2).title()print re.subn(pattern, func, s)### output #### ('say i, world hello!', 2)# ('I Say, Hello World!', 2)","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"python中cookie的用法","slug":"python中cookie的用法","date":"2017-09-04T09:11:01.000Z","updated":"2017-09-04T11:47:42.000Z","comments":true,"path":"2017/09/04/python中cookie的用法/","link":"","permalink":"http://yoursite.com/2017/09/04/python中cookie的用法/","excerpt":"（来自http://cuiqingcai.com/968.html ，基于python2） 当你获取一个URL你使用一个opener(一个urllib2.OpenerDirector的实例)。在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。 如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。","text":"（来自http://cuiqingcai.com/968.html ，基于python2） 当你获取一个URL你使用一个opener(一个urllib2.OpenerDirector的实例)。在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。 如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。 cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。Cookielib模块非常强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。 它们的关系：CookieJar —-派生—-&gt;FileCookieJar —-派生—–&gt;MozillaCookieJar和LWPCookieJar 123456789101112131415161718192021222324'''对于python3.4 cookie结构图: CookieJar / \\ \\ FileCookieJar \\ \\ / | \\ \\ \\ MozillaCookieJar | LWPCookieJar \\ \\ | | \\ | ---MSIEBase | \\ | / | | \\ | / MSIEDBCookieJar BSDDBCookieJar |/ MSIECookieJar ''' 获取Cookie保存到变量首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import urllib.requestimport http.cookiejar# python3的http.cookiejar相对于python2是cookielibif __name__ == '__main__': # 声明一个CookieJar对象实例来保存cookie cookie = http.cookiejar.CookieJar() # 利用HTTPCookieProcessor对象来创建cookie处理器 handler = urllib.request.HTTPCookieProcessor(cookie) # 通过handler来构建opener opener = urllib.request.build_opener(handler) response = opener.open(\"http://www.baidu.com\") for item in cookie: print('name = ' + item.name) print('value = ' + item.value)'''打印的结果name = BAIDUIDvalue = D604445C0C028E8ABE4264EC0CBD7E1D:FG=1name = BIDUPSIDvalue = D604445C0C028E8ABE4264EC0CBD7E1Dname = H_PS_PSSIDvalue = 1466_21089_22159name = PSTMvalue = 1504509252name = BDSVRTMvalue = 0name = BD_HOMEvalue = 0''''''基于python2的代码import urllib2import cookielibcookie = cookielib.CookieJar()#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器handler=urllib2.HTTPCookieProcessor(cookie)#通过handler来构建openeropener = urllib2.build_opener(handler)#此处的open方法同urllib2的urlopen方法，也可以传入requestresponse = opener.open('http://www.baidu.com')for item in cookie: print 'Name = '+item.name print 'Value = '+item.value ''' 保存Cookie到文件在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？这时，我们就要用到 FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存。 12345678910111213141516171819202122232425262728293031import urllib.requestimport http.cookiejarif __name__ == '__main__': # 设置保存cookie的文件，同级目录下的cookie.txt filename = 'cookie.txt' # 声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件 cookie = http.cookiejar.MozillaCookieJar(filename) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open(\"http://www.baidu.com\") # 保存cookie到文件 cookie.save(ignore_discard=True, ignore_expires=True) ''' ignore_discard: save even cookies set to be discarded.(即使cookies将被丢弃也将它保留下来) ignore_expires: save even cookies that have expired the file is overwritten if it already exists (若cookies已经存在，就覆盖原文件写入) ''' ''' cookie.txt的内容 # Netscape HTTP Cookie File # http://curl.haxx.se/rfc/cookie_spec.html # This is a generated file! Do not edit. .baidu.com TRUE / FALSE 3651994080 BAIDUID 5CEA0A924FE72079A5C5E4F66704297F:FG=1 .baidu.com TRUE / FALSE 3651994080 BIDUPSID 5CEA0A924FE72079A5C5E4F66704297F .baidu.com TRUE / FALSE H_PS_PSSID 1458_21105_18560_20927 .baidu.com TRUE / FALSE 3651994080 PSTM 1504510433 www.baidu.com FALSE / FALSE BDSVRTM 0 www.baidu.com FALSE / FALSE BD_HOME 0 ''' 从文件中获取Cookie并访问1234567891011def usecookie(): # 创建MozillaCookieJar实例对象 newcookie = http.cookiejar.MozillaCookieJar() # 从文件中读取cookie内容到变量 newcookie.load('cookie.txt', ignore_expires=True, ignore_discard=True) # 创建请求的request req = urllib.request.Request(\"http://www.baidu.com\") # 利用build_opener创建一个opener newopener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(newcookie)) resp = newopener.open(req) print(resp.read()) 利用cookie模拟登录豆瓣123456789101112131415161718192021filename = 'cookie.txt'# disable SSL verification, since it is default in python 2.7.9ssl._create_default_https_context = ssl._create_unverified_context# 声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)''' 数据编码，否则报错TypeError: POST data should be bytes, an iterable of bytes, or a file object. It cannot be of type str.'''data = urllib.parse.urlencode(&#123; 'form_email': '18883325578', 'form_password': '我的密码'&#125;).encode()url = \"https://accounts.douban.com/login\"response = opener.open(url, data)# 保存cookie到文件cookie.save(ignore_discard=True, ignore_expires=True)result = opener.open(\"http://www.douban.com\")soup = BeautifulSoup(result.read())print(soup) 要点: Python 2.7.9 之后版本引入了一个新特性，当你urllib.urlopen一个 https 的时候会验证一次 SSL 证书,当目标使用的是自签名的证书时就会爆出一个urllib.URLError: 的错误消息","categories":[],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://yoursite.com/tags/cookie/"}]},{"title":"cookies详解","slug":"cookies详解","date":"2017-09-04T06:40:47.000Z","updated":"2017-09-04T06:45:37.000Z","comments":true,"path":"2017/09/04/cookies详解/","link":"","permalink":"http://yoursite.com/2017/09/04/cookies详解/","excerpt":"(来自 http://blog.csdn.net/u012175089/article/details/70054806) HTTP cookies，通常又称作”cookies”早期Web开发面临的最大问题之一是如何管理状态。服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个token，并且在下一次请求中将这个token返回（至服务器）。这就需要在form中插入一个包含token的隐藏表单域，或着在URL的qurey字符串中传递该token。这两种办法都强调手工操作并且极易出错。cookies工作原理的基本信息在RFC2109中被规范化。","text":"(来自 http://blog.csdn.net/u012175089/article/details/70054806) HTTP cookies，通常又称作”cookies”早期Web开发面临的最大问题之一是如何管理状态。服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个token，并且在下一次请求中将这个token返回（至服务器）。这就需要在form中插入一个包含token的隐藏表单域，或着在URL的qurey字符串中传递该token。这两种办法都强调手工操作并且极易出错。cookies工作原理的基本信息在RFC2109中被规范化。 cookie是什么？一个cookie就是存储在用户主机浏览器中的一小段文本文件。Cookies是纯文本形式，它们不包含任何可执行代码。一个Web页面或服务器告之浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web服务器之后可以利用这些信息来标识用户。 – 通过HTTP的Set-Cookie消息头，Web服务器可以指定存储一个cookie。Set-Cookie消息的格式如下面的字符串（中括号中的部分都是可选的）Set-Cookie:value [ ;expires=date][ ;domain=domain][ ;path=path][ ;secure]value部分，通常是一个name=value格式的字符串。事实上有很多浏览器用自己的格式，有细微的不同。当一个cookie存在，并且可选条件允许的话，该cookie的值会在接下来的每个请求中被发送至服务器。 cookie的值被存储在名为Cookie的HTTP消息头中，并且只包含了cookie的值，其它的选项全部被去除。可选项只是存在于浏览器端，并不需要发给服务端。例如： Cookie : value如果在指定的请求中有多个cookies，那么它们会被分号和空格分开，例如：Cookie:value1 ; value2 ; name1=value1 有效期选项（The expires option）指定了cookie过期的时间，过期后可能会被浏览器删掉。格式为Wdy,DD-Mon–YYYY HH:MM:SS GMT，例如：Set-Cookie:name=Nicholas;expires=Sat, 02 May 2009 23:38:25 GMT在没有expires选项时，cookie的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话cookie只存在于浏览器保持打开的状态之下。 domain选项（The domain option）指示cookie将要发送到哪个域或那些域中。默认情况下，domain会被设置为创建该cookie的页面所在的域名。domain选项被用来扩展cookie值所要发送域的数量。例如:Set-Cookie:name=Nicholas;domain=www.baidu.com很多时候大网站存在二级域名，例如fanyi.baidu.com。cookies可能只发给对应的二级域名。 Path选项（The path option）在请求相匹配的路径的时候，才会发送cookie例如：Set-Cookie:name=Nicholas;path=/blog在这个例子中，path选项值会与/blog,/blogrool等等相匹配；任何以/blog开头的选项都是合法的。 secure选项（The secure option）该选项只是一个标记并且没有其它的值。只有当请求是通过SSL和HTTPS创建时，才会发送。这种cookie的内容意指具有很高的价值并且可能潜在的被破解以纯文本形式传输。例如Set-Cookie:name=Nicholas;secure现实中，机密且敏感的信息绝不应该在cookies中存储或传输，因为cookies的整个机制都是原本不安全的。默认情况下，在HTTPS链接上传输的cookies都会被自动添加上secure选项。 cookie的维护和生命周期（cookie maintenance and lifecycle）任意数量的选项都可以在单一的cookie中指定，并且这些选项可以以任何顺序存在，例如Set-Cookie:name=Nicholas; domain=nczonline.net; path=/blog这个cooke有四个标识符：cookie的name，domain，path，secure标记。要想在将来改变这个cookie的值，需要发送另一个具有相同cookie name,domain,path的Set-Cookie消息头。例如：Set-Cooke:name=Greg; domain=nczonline.net; path=/blog这将以一个新的值来覆盖原来cookie的值。然而，仅仅只是改变这些选项的某一个也会创建一个完全不同的cookie，例如：Set-Cookie:name=Nicholas; domain=nczonline.net; path=/在返回这个消息头后，会存在两个同时拥有“name”的不同的cookie。如果你访问在www.nczonline.NET/blog下的一个页面，以下的消息头将被包含进来：Cookie：name=Greg;name=Nicholas在这个消息头中存在了两个名为“name”的cookie，path值越详细则cookie越靠前。domain-path越详细则cookie字符串越靠前。假设我在ww.nczonline.Net/blog下并且发送了另一个cookie，其设置如下：Set-Cookie:name=Mike那么返回的消息头现在则变为：Cookie：name=Mike;name=Greg;name=Nicholas由于包含“Mike”的cookie使用了域名（www.nczonline.net）作为其domain值并且以全路径（/blog）作为其path值，则它较其它两个cookie更加详细。 使用失效日期（using expiration dates）当cookie创建时包含了失效日期，这个失效日期则关联了以name-domain-path-secure为标识的cookie。要改变一个cookie的失效日期，必须指定同样的组合。当改变一个cookie的值时，你不必每次都设置失效日期，因为它不是cookie标识信息的组成部分。例如：Set-Cookie:name=Mike;expires=Sat,03 May 2025 17:44:22 GMT现在已经设置了cookie的失效日期，所以下次我想要改变cookie的值时，我只需要使用它的名字：Set-Cookie:name=Matt在cookie上的失效日期并没有改变，因为cookie的标识符是相同的。实际上，只有你手工的改变cookie的失效日期，否则其失效日期不会改变。这意味着在同一个会话中，一个会话cookie可以变成一个持久化cookie（一个可以在多个会话中存在的），反之则不可。为了要将一个持久化cookie变为一个会话cookie，你必须删除这个持久化cookie，这只要设置它的失效日期为过去某个时间之后再创建一个同名的会话cookie就可以实现。需要记得的是失效日期是以浏览器运行的电脑上的系统时间为基准进行核实的。没有任何办法来来验证这个系统时间是否和服务器的时间同步，所以当服务器时间和浏览器所处系统时间存在差异时这样的设置会出现错误。 cookie自动删除（automatic cookie removal）cookie会被浏览器自动删除，通常存在以下几种原因：会话cooke(Session cookie)在会话结束时（浏览器关闭）会被删除持久化cookie（Persistent cookie）在到达失效日期时会被删除如果浏览器中的cookie限制到达，那么cookies会被删除以为新建cookies创建空间。对于任何这些自动删除来说，Cookie管理显得十分重要，因为这些删除都是无意识的。 Cookie限制条件（Cookie restrictions）在cookies上存在了诸多限制条件，来阻止cookie滥用并保护浏览器和服务器免受一些负面影响。有两种cookies的限制条件：cookies的属性和cookies的总大小。原始的规范中限定每个域名下不超过20个cookies，早期的浏览器都遵循该规范，并且在IE7中有个更近一步的提升。在微软的一次更新中，他们在IE7中增加cookies的限制到50个，与此同时Opera限定cookies个数为30.Safari和Chrome对与每个域名下的cookies个数没有限制。发向服务器的所有cookies的最大数量（空间）仍旧维持原始规范中所指出的：4KB。所有超出该限制的cookies都会被截掉并且不会发送至服务器。Subcookies鉴于cookie的数量限制，开发者提出的subcookies的观点来增加cookies的存储量。Subcookies是一些存储在一个cookie的value中的一些name-value对，并且通常与以下格式类似：name=a=b&amp;c=d&amp;e=f&amp;g=h这种方式允许在单个cookie中保存多个name-value对，而不会超过浏览器cookie的数量限制。通过这种方式创建cookies的负面影响是，需要自定义解析方式来提取这些值，相比较而言cookies的格式会更为简单。服务器端框架已开始支持subcookies的存储。","categories":[],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://yoursite.com/tags/cookie/"}]},{"title":"About Yield","slug":"About-Yield","date":"2017-08-11T06:32:42.000Z","updated":"2017-08-11T06:32:42.000Z","comments":true,"path":"2017/08/11/About-Yield/","link":"","permalink":"http://yoursite.com/2017/08/11/About-Yield/","excerpt":"写python遇到yield不是很懂。。。网上搜罗了一番 yield在python中作为生成器理解，主要用处是可以迭代，简化了很多运算模型。 yield是一个表达式，是有返回值的，如果说函数中含有yield时，它将不再是一个普通的函数，而是一个生成器，当该函数被调用时，不会自动执行，而是暂停。工作原理就是通过重复调用next()方法，直到捕获异常。yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。","text":"写python遇到yield不是很懂。。。网上搜罗了一番 yield在python中作为生成器理解，主要用处是可以迭代，简化了很多运算模型。 yield是一个表达式，是有返回值的，如果说函数中含有yield时，它将不再是一个普通的函数，而是一个生成器，当该函数被调用时，不会自动执行，而是暂停。工作原理就是通过重复调用next()方法，直到捕获异常。yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。 yield起源于对一般function中return的扩展，在一个function，必须有一个返回值列于return之后，且return意味中function的结束，一旦结束之后，函数里面的变量将被全部抛弃，如果需要让函数暂停下来，并返回当前所在地方的值，接收到后面的命令时又继续前进。 就像菲波那切数列，它是一个自循环数列，按照循环算法需要很大的运算量，同时，也并不知道何时会停下运算，如果采用动态记录的话，就会非常简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#菲波那切数列：每一个数都等于前两个数的和def fib(to = 10): curr = 0 next = 1 count = 0 while count &lt; to: yield curr curr = next next = curr + next count += 1if __name__ == '__main__': for x in fib(10): print(x + 1)#得到的值 \"\"\"12359173365129257\"\"\"#另一个例子&gt;&gt;&gt; def fun2(): print 'first' yield 5 print 'second' yield 23 print 'end...' &gt;&gt;&gt; g1 = fun2() &gt;&gt;&gt; g1.next() #第一次运行,暂停在yield 5 first 5 &gt;&gt;&gt; g1.next() #第二次运行,暂停在yield 23 second 23 &gt;&gt;&gt; g1.next() #第三次运行,由于之后没有yield,再次next()就会抛出错误 end... Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; StopIteration ps：未完待续。。。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"关于threading","slug":"关于threading","date":"2017-08-10T08:38:30.000Z","updated":"2017-08-11T08:32:31.000Z","comments":true,"path":"2017/08/10/关于threading/","link":"","permalink":"http://yoursite.com/2017/08/10/关于threading/","excerpt":"threading模块包含的方法python中的threading模块包含了一下的一些方法： threading.acitve_count()返回正在运行的线程对象的个数，返回的个数和enumerate()方法返回的线程列表长度一致。 threading.current_thread()返回当前线程对象。如果调用者的控制线程不是通过threading模块创建的，将会返回被限制功能的虚拟线程对象 threading.get_indent()返回当前线程的线程标识符，它的值没有实际意义。 threading.enumerate()返回当前运行中的线程列表，包括守护线程、主线程，由current_thread（）创建的虚拟线程。不包括终止的线程和尚未启动的线程。 threading.main_thread()返回主线程对象，在正常情况下，主线程是有python解释器开始的线程","text":"threading模块包含的方法python中的threading模块包含了一下的一些方法： threading.acitve_count()返回正在运行的线程对象的个数，返回的个数和enumerate()方法返回的线程列表长度一致。 threading.current_thread()返回当前线程对象。如果调用者的控制线程不是通过threading模块创建的，将会返回被限制功能的虚拟线程对象 threading.get_indent()返回当前线程的线程标识符，它的值没有实际意义。 threading.enumerate()返回当前运行中的线程列表，包括守护线程、主线程，由current_thread（）创建的虚拟线程。不包括终止的线程和尚未启动的线程。 threading.main_thread()返回主线程对象，在正常情况下，主线程是有python解释器开始的线程 ​ … Thread对象Thread类是一种在单独的控制线程中运行的活动，只有两种方法来具象这个活动：给构造函数传递一个可调用对象，或者在子类中覆盖run()方法。在这个类中国年只有__init__()和run()方法可以被覆盖。 一旦线程对象被创建，必须通过调用start()方法来开启线程活动，将会调用另一个单独的控制线程中的run()方法。 线程只有被启动就会处于活跃状态，只有在run()终止或者诱发了一个未处理的异常才会终止线程，可以使用is_alive()方法来检测线程是否处于活跃状态。 join()方法将会阻止线程的调用，直到调用join()方法的线程终止。 线程有名字，可以传递给构造函数，并通过该属性读取或者修改线程名。 class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, **, daemon=None*) 如果子类覆盖了构造函数，那么必须在对线程操作前调用基类构造函数的Thread.__init__()方法。 start()启动线程，每个线程最多且必须调用一次 run()表示线程活动的方法。 join()等待线程终止。 name() getName() setName() ident() is_alive() daemon()一个布尔值，指示此线程是否为守护线程（True）或否（False）。这必须在start()被调用之前设置。主线程不是守护线程，因此在主线程中创建的所有线程都默认为daemon= False。 isDaemon() setDaemon() 参考：https://docs.python.org/3.6/library/threading.html 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-import threadingclass threadpro (threading.Thread):#继承父类的threading.Thread def __init__(self,threadID, name): threading.Thread.__init__(self) self.threadID = threadID self.name = name def run(self):#表示线程活动的方法，线程创建后直接运行run函数 print('------\\nstarting ' + self.name) print(threading.active_count())#查看当前活跃的进程数 for i in range(threading.active_count()): print(threading.enumerate()[i].getName())#打印进程名 print(\"Exiting \" + self.name )threadpool = []thread1 = threadpro(1,'thread-1')thread2 = threadpro(2,'thread-2')threadpool.append(thread1)threadpool.append(thread2)thread1.start()thread2.start()#结果#------#starting thread-1#2#MainThread#thread-1#Exiting thread-1#------#starting thread-2#2#MainThread#thread-2#Exiting thread-2","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Beautiful Soup","slug":"Beautiful-Soup","date":"2017-08-09T02:55:39.000Z","updated":"2017-08-11T03:41:11.000Z","comments":true,"path":"2017/08/09/Beautiful-Soup/","link":"","permalink":"http://yoursite.com/2017/08/09/Beautiful-Soup/","excerpt":"一、简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库，能够通过喜欢的转换器实现管用的文档导航，查找，修改文档的方式。Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能，它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完成的应用程序。Beautiful Soup自动将输入文档转换为unicode编码，输出文档转换为utf-8编码。","text":"一、简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库，能够通过喜欢的转换器实现管用的文档导航，查找，修改文档的方式。Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能，它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完成的应用程序。Beautiful Soup自动将输入文档转换为unicode编码，输出文档转换为utf-8编码。例如当一段HTML代码被多次用到，用BeautifulSoup解这段HTML代码， 可以实现标准的缩进格式的代码。 以下是示例 123456789101112131415161718192021222324252627282930313233343536from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc)print(soup.prettify())# &lt;html&gt;# &lt;head&gt;# &lt;title&gt;# The Dormouse's story# &lt;/title&gt;# &lt;/head&gt;# &lt;body&gt;# &lt;p class=\"title\"&gt;# &lt;b&gt;# The Dormouse's story# &lt;/b&gt;# &lt;/p&gt;# &lt;p class=\"story\"&gt;# Once upon a time there were three little sisters; and their names were# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;# Elsie# &lt;/a&gt;# ,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;# Lacie# &lt;/a&gt;# and# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link2\"&gt;# Tillie# &lt;/a&gt;# ; and they lived at the bottom of a well.# &lt;/p&gt;# &lt;p class=\"story\"&gt;# ...# &lt;/p&gt;# &lt;/body&gt;# &lt;/html&gt; 从文档中找所有标签的链接： 12345for link in soup.find_all('a'): print(link.get('href')) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie 从文档中获取所有文字内容： 123456789101112print(soup.get_text())# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their names were# Elsie,# Lacie and# Tillie;# and they lived at the bottom of a well.## ... 二、使用方法将一段文档传入BeautifulSoup的构造方法，从而得到一个文档对象。 123from bs4 import BeautifulSoupsoup = BeautifulSoup(open('index.html'))soup = BeautifulSoup(\"&lt;html&gt;data&lt;/html&gt;\") Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-07-27T03:42:57.000Z","updated":"2017-07-27T03:42:57.000Z","comments":true,"path":"2017/07/27/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}