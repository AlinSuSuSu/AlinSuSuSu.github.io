{"meta":{"title":"Su's Blog","subtitle":"Day Day Up","description":null,"author":"SuQ","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-07-28T07:42:04.000Z","updated":"2017-07-28T07:42:04.000Z","comments":true,"path":"readme.html","permalink":"http://yoursite.com/readme.html","excerpt":"","text":"部署三部曲： hexo clean hexo generate #生成静态页面到public目录 hexo deploy #部署.deploy项目到github 常用命令： hexo new “postName” #新建文章 hexo new page “pagename” #新建页面"},{"title":"about","date":"2017-07-29T08:17:54.000Z","updated":"2017-07-29T08:17:54.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-07-29T08:13:55.000Z","updated":"2017-07-29T08:14:41.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-29T08:18:21.000Z","updated":"2017-07-29T08:19:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"About Yield","slug":"About-Yield","date":"2017-08-11T06:32:42.000Z","updated":"2017-08-11T06:32:42.000Z","comments":true,"path":"2017/08/11/About-Yield/","link":"","permalink":"http://yoursite.com/2017/08/11/About-Yield/","excerpt":"写python遇到yield不是很懂。。。网上搜罗了一番 yield在python中作为生成器理解，主要用处是可以迭代，简化了很多运算模型。 yield是一个表达式，是有返回值的，如果说函数中含有yield时，它将不再是一个普通的函数，而是一个生成器，当该函数被调用时，不会自动执行，而是暂停。工作原理就是通过重复调用next()方法，直到捕获异常。yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。","text":"写python遇到yield不是很懂。。。网上搜罗了一番 yield在python中作为生成器理解，主要用处是可以迭代，简化了很多运算模型。 yield是一个表达式，是有返回值的，如果说函数中含有yield时，它将不再是一个普通的函数，而是一个生成器，当该函数被调用时，不会自动执行，而是暂停。工作原理就是通过重复调用next()方法，直到捕获异常。yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。 yield起源于对一般function中return的扩展，在一个function，必须有一个返回值列于return之后，且return意味中function的结束，一旦结束之后，函数里面的变量将被全部抛弃，如果需要让函数暂停下来，并返回当前所在地方的值，接收到后面的命令时又继续前进。 就像菲波那切数列，它是一个自循环数列，按照循环算法需要很大的运算量，同时，也并不知道何时会停下运算，如果采用动态记录的话，就会非常简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#菲波那切数列：每一个数都等于前两个数的和def fib(to = 10): curr = 0 next = 1 count = 0 while count &lt; to: yield curr curr = next next = curr + next count += 1if __name__ == '__main__': for x in fib(10): print(x + 1)#得到的值 \"\"\"12359173365129257\"\"\"#另一个例子&gt;&gt;&gt; def fun2(): print 'first' yield 5 print 'second' yield 23 print 'end...' &gt;&gt;&gt; g1 = fun2() &gt;&gt;&gt; g1.next() #第一次运行,暂停在yield 5 first 5 &gt;&gt;&gt; g1.next() #第二次运行,暂停在yield 23 second 23 &gt;&gt;&gt; g1.next() #第三次运行,由于之后没有yield,再次next()就会抛出错误 end... Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; StopIteration ps：未完待续。。。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"关于threading","slug":"关于threading","date":"2017-08-10T08:38:30.000Z","updated":"2017-08-11T07:52:47.000Z","comments":true,"path":"2017/08/10/关于threading/","link":"","permalink":"http://yoursite.com/2017/08/10/关于threading/","excerpt":"threading模块包含的方法python中的threading模块包含了一下的一些方法： threading.acitve_count()返回正在运行的线程对象的个数，返回的个数和enumerate()方法返回的线程列表长度一致。 threading.current_thread()返回当前线程对象。如果调用者的控制线程不是通过threading模块创建的，将会返回被限制功能的虚拟线程对象 threading.get_indent()返回当前线程的线程标识符，它的值没有实际意义。 threading.enumerate()返回当前运行中的线程列表，包括守护线程、主线程，由current_thread（）创建的虚拟线程。不包括终止的线程和尚未启动的线程。 threading.main_thread()返回主线程对象，在正常情况下，主线程是有python解释器开始的线程","text":"threading模块包含的方法python中的threading模块包含了一下的一些方法： threading.acitve_count()返回正在运行的线程对象的个数，返回的个数和enumerate()方法返回的线程列表长度一致。 threading.current_thread()返回当前线程对象。如果调用者的控制线程不是通过threading模块创建的，将会返回被限制功能的虚拟线程对象 threading.get_indent()返回当前线程的线程标识符，它的值没有实际意义。 threading.enumerate()返回当前运行中的线程列表，包括守护线程、主线程，由current_thread（）创建的虚拟线程。不包括终止的线程和尚未启动的线程。 threading.main_thread()返回主线程对象，在正常情况下，主线程是有python解释器开始的线程 ​ … Thread对象Thread类是一种在单独的控制线程中运行的活动，只有两种方法来具象这个活动：给构造函数传递一个可调用对象，或者在子类中覆盖run()方法。在这个类中国年只有__init__()和run()方法可以被覆盖。 一旦线程对象被创建，必须通过调用start()方法来开启线程活动，将会调用另一个单独的控制线程中的run()方法。 线程只有被启动就会处于活跃状态，只有在run()终止或者诱发了一个未处理的异常才会终止线程，可以使用is_alive()方法来检测线程是否处于活跃状态。 join()方法将会阻止线程的调用，直到调用join()方法的线程终止。 线程有名字，可以传递给构造函数，并通过该属性读取或者修改线程名。 class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, **, daemon=None*) 如果子类覆盖了构造函数，那么必须在对线程操作前调用基类构造函数的Thread.__init__()方法。 start()启动线程，每个线程最多且必须调用一次 run()表示线程活动的方法。 join()等待线程终止。 name() getName() setName() ident() is_alive() daemon()一个布尔值，指示此线程是否为守护线程（True）或否（False）。这必须在start()被调用之前设置。主线程不是守护线程，因此在主线程中创建的所有线程都默认为daemon= False。 isDaemon() setDaemon() 来自：https://docs.python.org/3.6/library/threading.html","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Beautiful Soup","slug":"Beautiful-Soup","date":"2017-08-09T02:55:39.000Z","updated":"2017-08-11T03:41:11.000Z","comments":true,"path":"2017/08/09/Beautiful-Soup/","link":"","permalink":"http://yoursite.com/2017/08/09/Beautiful-Soup/","excerpt":"一、简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库，能够通过喜欢的转换器实现管用的文档导航，查找，修改文档的方式。Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能，它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完成的应用程序。Beautiful Soup自动将输入文档转换为unicode编码，输出文档转换为utf-8编码。","text":"一、简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库，能够通过喜欢的转换器实现管用的文档导航，查找，修改文档的方式。Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能，它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完成的应用程序。Beautiful Soup自动将输入文档转换为unicode编码，输出文档转换为utf-8编码。例如当一段HTML代码被多次用到，用BeautifulSoup解这段HTML代码， 可以实现标准的缩进格式的代码。 以下是示例 123456789101112131415161718192021222324252627282930313233343536from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc)print(soup.prettify())# &lt;html&gt;# &lt;head&gt;# &lt;title&gt;# The Dormouse's story# &lt;/title&gt;# &lt;/head&gt;# &lt;body&gt;# &lt;p class=\"title\"&gt;# &lt;b&gt;# The Dormouse's story# &lt;/b&gt;# &lt;/p&gt;# &lt;p class=\"story\"&gt;# Once upon a time there were three little sisters; and their names were# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;# Elsie# &lt;/a&gt;# ,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;# Lacie# &lt;/a&gt;# and# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link2\"&gt;# Tillie# &lt;/a&gt;# ; and they lived at the bottom of a well.# &lt;/p&gt;# &lt;p class=\"story\"&gt;# ...# &lt;/p&gt;# &lt;/body&gt;# &lt;/html&gt; 从文档中找所有标签的链接： 12345for link in soup.find_all('a'): print(link.get('href')) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie 从文档中获取所有文字内容： 123456789101112print(soup.get_text())# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their names were# Elsie,# Lacie and# Tillie;# and they lived at the bottom of a well.## ... 二、使用方法将一段文档传入BeautifulSoup的构造方法，从而得到一个文档对象。 123from bs4 import BeautifulSoupsoup = BeautifulSoup(open('index.html'))soup = BeautifulSoup(\"&lt;html&gt;data&lt;/html&gt;\") Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .","categories":[],"tags":[]},{"title":"someproblemsimet","slug":"someproblemsimet","date":"2017-08-06T10:29:02.000Z","updated":"2017-08-07T02:02:25.000Z","comments":true,"path":"2017/08/06/someproblemsimet/","link":"","permalink":"http://yoursite.com/2017/08/06/someproblemsimet/","excerpt":"","text":"python 解决NAMEError：name ‘reload’ is not defined的问题 对于python 2.x: 123import sysreload(sys)sys.setdefaultencoding(\"utf-8\") 对于python&lt;=3.3: 12345import impimp.reload(sys)'''python3与python 2有很大的区别，python3系统默认使用的是UTF-8编码，所以，对于使用的是python3的情况不需要使用sys.setdefaultencoding('utf-8')这段代码，并且python3中已经没有setdefaultencoding这个函数了 ''' 对于python&gt;=3.4: 12import importlibimportlib.reload(sys) 在python3中已经没有StringIO模块，修改为io模块","categories":[],"tags":[]},{"title":"About urllib2","slug":"About-urllib2","date":"2017-07-31T02:54:56.000Z","updated":"2017-07-31T02:54:56.000Z","comments":true,"path":"2017/07/31/About-urllib2/","link":"","permalink":"http://yoursite.com/2017/07/31/About-urllib2/","excerpt":"","text":"","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-27T03:42:57.000Z","updated":"2017-07-27T03:42:57.000Z","comments":true,"path":"2017/07/27/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}